# Template Method

-   Design pattern to separate generic algorithms from specific implementation details.
-   You capture all common, generic code among a group of algorithms in a base class, while delegating the details to subclasses via abstract methods.
-   This is the inheritance equivalent of the [Strategy](/design-patterns/strategy) pattern.
    -   Downside is that you tightly couple the implementation details to the base class.
-   UML Diagram
    ![Template Method UML](/template-method-uml.png)

## When to use

-   When you have a group of algorithms with some common code, but details you want to separate out into subclasses.

## Example 1: House Builder

```
// The "Template" abstract class
abstract class HouseBuilder {
	// Common methods
	public buildHouse() {
		this.buildFoundation();
		this.buildWalls();
		this.buildWindows();
		this.buildRoof();
	}

	public buildFoundation() {
		console.log('Building foundation');
	}

	abstract buildWalls(): void;
	abstract buildWindows(): void;
	abstract buildRoof(): void;
}

// Detailed implementations
class WoodenHouseBuilder extends HouseBuilder {
	buildWalls(): void {
		console.log('Building wooden walls');
	}
	buildWindows(): void {
		console.log('Building wooden windows');
	}
	buildRoof(): void {
		console.log('Building a wooden roof');
	}
}

class GlassHouseBuilder extends HouseBuilder {
	buildWalls(): void {
		console.log('Building glass walls');
	}
	buildWindows(): void {
		console.log('Building glass windows');
	}
	buildRoof(): void {
		console.log('Building a glass roof');
	}
}
```
